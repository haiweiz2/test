DefaultAuthorizationCodeTokenResponseClient
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.10.0</version> <!-- Use the compatible version -->
</dependency>



new RestTemplate(Arrays.asList(
            new FormHttpMessageConverter(),  // For handling form-encoded responses
            new MappingJackson2HttpMessageConverter() // For handling JSON responses
        ));






import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.http.RequestEntity;
import org.springframework.security.oauth2.client.endpoint.OAuth2AccessTokenResponseClient;
import org.springframework.security.oauth2.client.endpoint.OAuth2AuthorizationCodeGrantRequest;
import org.springframework.security.oauth2.client.endpoint.OAuth2AuthorizationCodeGrantRequestEntityConverter;
import org.springframework.security.oauth2.core.OAuth2AccessTokenResponse;
import org.springframework.security.oauth2.core.endpoint.OAuth2ParameterNames;
import org.springframework.web.client.RestTemplate;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

public class CustomOAuth2AccessTokenResponseClient 
    implements OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {

    private final RestTemplate restTemplate = new RestTemplate();
    private final OAuth2AuthorizationCodeGrantRequestEntityConverter requestEntityConverter = 
        new OAuth2AuthorizationCodeGrantRequestEntityConverter();

    @Override
    public OAuth2AccessTokenResponse getTokenResponse(OAuth2AuthorizationCodeGrantRequest authorizationGrantRequest) {
        RequestEntity<?> requestEntity = requestEntityConverter.convert(authorizationGrantRequest);

        // Extract the original form parameters
        MultiValueMap<String, String> formParameters = new LinkedMultiValueMap<>();
        formParameters.putAll((MultiValueMap<String, String>) requestEntity.getBody());

        // Add PKCE parameters
        formParameters.add("code_challenge", "<your_code_challenge>");
        formParameters.add("code_challenge_method", "S256");

        // Rebuild the request entity with updated form parameters
        RequestEntity<MultiValueMap<String, String>> updatedRequestEntity = new RequestEntity<>(
            formParameters,
            requestEntity.getHeaders(),
            requestEntity.getMethod(),
            requestEntity.getUrl()
        );

        // Execute the request with the modified entity
        return restTemplate.exchange(
            updatedRequestEntity,
            OAuth2AccessTokenResponse.class
        ).getBody();
    }
}



















import org.springframework.security.oauth2.client.endpoint.OAuth2AuthorizationCodeGrantRequest;
import org.springframework.security.oauth2.client.endpoint.OAuth2AccessTokenResponseClient;
import org.springframework.security.oauth2.client.endpoint.DefaultAuthorizationCodeTokenResponseClient;
import org.springframework.security.oauth2.core.endpoint.OAuth2ParameterNames;
import org.springframework.security.oauth2.core.endpoint.OAuth2AccessTokenResponse;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

public class CustomOAuth2AccessTokenResponseClient implements OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {
    
    private final DefaultAuthorizationCodeTokenResponseClient defaultClient = new DefaultAuthorizationCodeTokenResponseClient();

    @Override
    public OAuth2AccessTokenResponse getTokenResponse(OAuth2AuthorizationCodeGrantRequest authorizationGrantRequest) {
        // Create a new token request with additional PKCE parameters
        MultiValueMap<String, String> formParameters = new LinkedMultiValueMap<>(authorizationGrantRequest.getAuthorizationExchange()
                .getAuthorizationResponse()
                .getAdditionalParameters());

        // Add PKCE parameters
        formParameters.add("code_verifier", "your_generated_code_verifier");
        formParameters.add("code_challenge_method", "S256"); // or "plain" if your server doesn't support S256

        // Set the updated parameters back to the request
        OAuth2AuthorizationCodeGrantRequest updatedRequest = new OAuth2AuthorizationCodeGrantRequest(
                authorizationGrantRequest.getClientRegistration(),
                authorizationGrantRequest.getAuthorizationExchange(),
                formParameters
        );

        return defaultClient.getTokenResponse(updatedRequest);
    }
}



















.accessTokenResponseClient(new CustomOAuth2AccessTokenResponseClient()); // Custom client for PKCE



import org.springframework.security.oauth2.client.endpoint.OAuth2AccessTokenResponseClient;
import org.springframework.security.oauth2.client.endpoint.OAuth2AuthorizationCodeGrantRequest;
import org.springframework.security.oauth2.client.endpoint.OAuth2AuthorizationCodeGrantRequestEntityConverter;
import org.springframework.security.oauth2.core.endpoint.OAuth2ParameterNames;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.RequestEntity;
import org.springframework.security.oauth2.core.OAuth2AccessTokenResponse;

public class CustomOAuth2AccessTokenResponseClient 
    implements OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {

    private final RestTemplate restTemplate = new RestTemplate();

    @Override
    public OAuth2AccessTokenResponse getTokenResponse(OAuth2AuthorizationCodeGrantRequest authorizationGrantRequest) {
        OAuth2AuthorizationCodeGrantRequestEntityConverter converter = 
            new OAuth2AuthorizationCodeGrantRequestEntityConverter();
        RequestEntity<?> requestEntity = converter.convert(authorizationGrantRequest);

        // Add code_challenge_method and code_challenge to the request
        UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromUri(requestEntity.getUrl())
            .queryParam("code_challenge", "<your_code_challenge>")
            .queryParam("code_challenge_method", "S256"); // Use S256 as the PKCE method

        // Send the request with the added PKCE parameters
        return restTemplate.exchange(uriBuilder.toUriString(), 
            requestEntity.getMethod(), requestEntity, OAuth2AccessTokenResponse.class).getBody();
    }
}





@Override
public OAuth2AccessTokenResponse getTokenResponse(OAuth2AuthorizationCodeGrantRequest request) {
    // Define the token URI for your authorization server
    String tokenUri = "https://{okta_domain}/oauth2/default/v1/token";

    // Retrieve the authorization code
    String authorizationCode = request.getAuthorizationExchange()
                                      .getAuthorizationResponse()
                                      .getCode();

    // Prepare the parameters for the token request
    MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
    params.add("client_id", "your-client-id");
    params.add("client_secret", "your-client-secret");
    params.add("code", authorizationCode);
    params.add("redirect_uri", request.getAuthorizationExchange().getAuthorizationRequest().getRedirectUri());
    params.add("grant_type", "authorization_code");

    // Create the HTTP entity with headers and parameters
    HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, new HttpHeaders());

    // Execute the token request using RestTemplate
    ResponseEntity<OAuth2AccessTokenResponse> responseEntity = restTemplate.exchange(
            tokenUri, HttpMethod.POST, entity, OAuth2AccessTokenResponse.class);

    return responseEntity.getBody(); // Return the OAuth2AccessTokenResponse
}








  // Custom OAuth2 Access Token Response Client
    private static class CustomOAuth2AccessTokenResponseClient implements OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {

        private final RestTemplate restTemplate;

        public CustomOAuth2AccessTokenResponseClient(RestTemplate restTemplate) {
            this.restTemplate = restTemplate;
        }

        @Override
        public OAuth2AccessTokenResponse getTokenResponse(OAuth2AuthorizationCodeGrantRequest request) {
            // Manually specify the token URI for the authorization server
            String tokenUri = "https://{okta_domain}/oauth2/default/v1/token"; // Example token URI

            // Prepare the token request (You can customize the request body and parameters)
            MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
            params.add("client_id", "your-client-id");
            params.add("client_secret", "your-client-secret");
            params.add("code", request.getAuthorizationExchange().getAuthorizationCode());
            params.add("redirect_uri", request.getAuthorizationExchange().getRedirectUri());
            params.add("grant_type", "authorization_code");

            // Exchange the code for an access token
            HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, new HttpHeaders());
            ResponseEntity<OAuth2AccessTokenResponse> responseEntity = restTemplate.exchange(
                    tokenUri, HttpMethod.POST, entity, OAuth2AccessTokenResponse.class);

            return responseEntity.getBody(); // Return the access token response
        }
    }






    @Autowired
    private RestTemplate restTemplate;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/welcome").permitAll() // Allow access to public pages
                .anyRequest().authenticated() // Protect other pages
            .and()
                .oauth2Login() // Enable OAuth2 login
                .tokenEndpoint()
                    .accessTokenResponseClient(new CustomOAuth2AccessTokenResponseClient(restTemplate))
            .and()
            .defaultSuccessUrl("/main", true); // Redirect to main page after login
    }
}

private static class CustomOAuth2AccessTokenResponseClient implements OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {

    private final RestTemplate restTemplate;

    public CustomOAuth2AccessTokenResponseClient(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @Override
    public OAuth2AccessTokenResponse getTokenResponse(OAuth2AuthorizationCodeGrantRequest request) {
        // Custom implementation for token exchange using RestTemplate with timeout
        return restTemplate.exchange(request.getTokenUri(), HttpMethod.POST, null, OAuth2AccessTokenResponse.class).getBody();
    }
}







 @Bean
    public OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> client() {
        return new DefaultOAuth2AccessTokenResponseClient() {
            @Override
            public OAuth2AccessTokenResponse getTokenResponse(OAuth2AuthorizationCodeGrantRequest authorizationCodeGrantRequest) {
                OAuth2AccessTokenResponse response = super.getTokenResponse(authorizationCodeGrantRequest);
                // Here, you can apply additional logic to modify the response if needed
                return response;
            }
        };
    }




@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private RestTemplate restTemplate;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
            .and()
                .oauth2Login()
                .tokenEndpoint()
                    .accessTokenResponseClient(accessTokenResponseClient());
    }

    @Bean
    public OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> accessTokenResponseClient() {
        DefaultOAuth2AccessTokenResponseClient tokenResponseClient = new DefaultOAuth2AccessTokenResponseClient();
        tokenResponseClient.setRestTemplate(restTemplate);  // Use the custom RestTemplate here
        return tokenResponseClient;
    }
}




@Bean
    public RestTemplate restTemplate() {
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(30000);  // Set connection timeout to 30 seconds
        factory.setReadTimeout(30000);     // Set read timeout to 30 seconds
        return new RestTemplate(factory);
    }

   @Autowired
    private WebClient.Builder webClientBuilder;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .anyRequest().authenticated()
            .and()
                .oauth2Login()
                    .clientRegistrationRepository(clientRegistrationRepository())
                    .authorizedClientService(authorizedClientService())
                    .tokenEndpoint()
                        .accessTokenResponseClient(this.accessTokenResponseClient());
    }

    private OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> accessTokenResponseClient() {
        OAuth2AuthorizationCodeGrantRequestEntityConverter converter =
                new OAuth2AuthorizationCodeGrantRequestEntityConverter();
        return new DefaultOAuth2AccessTokenResponseClient(converter);
    }







   @Bean
    public WebClient.Builder webClientBuilder() {
        return WebClient.builder()
                .clientConnector(new ReactorClientHttpConnector(HttpClient.create()
                    .responseTimeout(Duration.ofSeconds(30))  // Increase timeout here
                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 30000)));  // Set connect timeout
    }







<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpclient</artifactId>
    <version>4.5.13</version> <!-- Check for the latest version -->
</dependency>








import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.client.config.RequestConfig;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

@Configuration
public class OAuth2Config {

    @Bean
    public RestTemplate restTemplate() {
        // Set up connection pooling
        PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();
        connectionManager.setMaxTotal(200);  // Max total connections
        connectionManager.setDefaultMaxPerRoute(20);  // Max connections per route

        // Set the timeout values
        CloseableHttpClient httpClient = HttpClients.custom()
            .setDefaultRequestConfig(
                RequestConfig.custom()
                    .setConnectTimeout(5000)  // Connection timeout in milliseconds
                    .setSocketTimeout(10000)  // Read timeout in milliseconds
                    .build()
            )
            .setConnectionManager(connectionManager)
            .build();

        HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(httpClient);
        return new RestTemplate(factory);
    }
}




















@Bean
    public ClientRegistrationRepository clientRegistrationRepository() {
        return new InMemoryClientRegistrationRepository(oktaClientRegistration());
    }

    @Bean
    public OAuth2AuthorizedClientService authorizedClientService(ClientRegistrationRepository clientRegistrationRepository) {
        return new InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository);
    }

------------
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.oauth2.client.registration.ClientRegistration;
import org.springframework.security.oauth2.client.registration.ClientRegistrationRepository;
import org.springframework.security.oauth2.client.registration.InMemoryClientRegistrationRepository;
import org.springframework.security.oauth2.client.web.OAuth2AuthorizedClientService;
import org.springframework.security.oauth2.client.web.OAuth2AuthorizedClientService;
import org.springframework.security.oauth2.client.web.OAuth2AuthorizedClientRepository;
import org.springframework.security.oauth2.client.web.DefaultOAuth2AuthorizedClientService;
import org.springframework.security.oauth2.core.oidc.user.OidcUser;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/", "/public/**").permitAll() // Public paths
                .anyRequest().authenticated() // Protect all other paths
            .and()
            .oauth2Login() // Enable OAuth2 login
                .loginPage("/login") // Optional: custom login page
                .defaultSuccessUrl("/home", true); // Redirect after login
    }

    @Bean
    public ClientRegistrationRepository clientRegistrationRepository() {
        return new InMemoryClientRegistrationRepository(oktaClientRegistration());
    }

    @Bean
    public ClientRegistration oktaClientRegistration() {
        return ClientRegistration.withRegistrationId("okta")
            .clientId("{yourClientId}")
            .clientSecret("{yourClientSecret}")
            .scope("openid", "profile", "email")
            .authorizationUri("https://{yourOktaDomain}/oauth2/default/v1/authorize")
            .tokenUri("https://{yourOktaDomain}/oauth2/default/v1/token")
            .jwkSetUri("https://{yourOktaDomain}/oauth2/default/v1/keys")
            .userInfoUri("https://{yourOktaDomain}/oauth2/default/v1/userinfo")
            .redirectUri("{yourRedirectUri}")
            .issuerUri("https://{yourOktaDomain}/oauth2/default")
            .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
            .build();
    }

    @Bean
    public OAuth2AuthorizedClientService authorizedClientService(ClientRegistrationRepository clientRegistrationRepository) {
        return new DefaultOAuth2AuthorizedClientService(clientRegistrationRepository);
    }
}


------
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
            .antMatchers("/", "/public/**").permitAll()
            .anyRequest().authenticated()
            .and()
            .oauth2Login()
                .defaultSuccessUrl("/home", true);

        return http.build();
    }
}
------











# Okta OAuth2 Configuration
spring.security.oauth2.client.registration.okta.client-id={yourClientId}
spring.security.oauth2.client.registration.okta.client-secret={yourClientSecret}
spring.security.oauth2.client.registration.okta.scope=openid, profile, email
spring.security.oauth2.client.registration.okta.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.okta.redirect-uri=http://localhost:8080/login/oauth2/code/okta
spring.security.oauth2.client.registration.okta.client-authentication-method=client_secret_basic

# Okta Provider Information
spring.security.oauth2.client.provider.okta.issuer-uri=https://{yourOktaDomain}/oauth2/default
spring.security.oauth2.client.provider.okta.authorization-uri=https://{yourOktaDomain}/oauth2/default/v1/authorize
spring.security.oauth2.client.provider.okta.token-uri=https://{yourOktaDomain}/oauth2/default/v1/token
spring.security.oauth2.client.provider.okta.user-info-uri=https://{yourOktaDomain}/oauth2/default/v1/userinfo
spring.security.oauth2.client.provider.okta.jwk-set-uri=https://{yourOktaDomain}/oauth2/default/v1/keys







=================
Yes, you can still integrate Okta with Spring 5.0.16. However, the okta-spring-boot-starter library is typically used with more recent versions of Spring Boot, and if you are using plain Spring 5 (not Spring Boot), the integration process will require a bit more manual configuration, especially for OAuth 2.0 login.

Steps to Integrate Okta with Spring 5.0.16
Add Okta Dependencies

You'll need the following dependencies for OAuth 2.0 integration, including Spring Security OAuth 2.0 support. Add them to your pom.xml:

xml
Copy code
<!-- Okta Spring Security Starter -->
<dependency>
    <groupId>com.okta.spring</groupId>
    <artifactId>okta-spring-security-oauth2</artifactId>
    <version>3.0.1</version>
</dependency>

<!-- Spring Security OAuth2 Client -->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-oauth2-client</artifactId>
    <version>5.0.16.RELEASE</version>
</dependency>

<!-- Spring Security Core -->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-core</artifactId>
    <version>5.0.16.RELEASE</version>
</dependency>

<!-- Spring Security Web -->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-web</artifactId>
    <version>5.0.16.RELEASE</version>
</dependency>
These dependencies bring OAuth 2.0 login functionality, even with Spring 5.0.16.

Configure Okta in application.properties

Add Okta OAuth 2.0 credentials to your application.properties:

properties
Copy code
okta.oauth2.issuer=https://{yourOktaDomain}/oauth2/default
okta.oauth2.client-id={yourClientId}
okta.oauth2.client-secret={yourClientSecret}

# Optional, the default redirect URI:
spring.security.oauth2.client.registration.okta.redirect-uri=http://localhost:8080/login/oauth2/code/okta
Replace {yourOktaDomain}, {yourClientId}, and {yourClientSecret} with your actual Okta details from the Okta developer console.

Configure Spring Security

Since you're using Spring 5.0.16, you need to manually configure the OAuth 2.0 login flow. Here is an example of how to configure Spring Security:

java
Copy code
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
            .antMatchers("/", "/public/**").permitAll()
            .anyRequest().authenticated()
            .and()
            .oauth2Login()  // Enables OAuth2 login
                .defaultSuccessUrl("/home", true);  // Redirect after successful login
    }
}
This configuration protects all endpoints except /public/** and redirects users to the Okta login page when trying to access secure endpoints.
Manual OAuth 2.0 Configuration in Spring 5

Since you’re using Spring 5, you might need to manually configure the client registration and provider details. Add the following configuration in application.properties:

properties
Copy code
spring.security.oauth2.client.registration.okta.client-id={yourClientId}
spring.security.oauth2.client.registration.okta.client-secret={yourClientSecret}
spring.security.oauth2.client.registration.okta.scope=openid, profile, email
spring.security.oauth2.client.registration.okta.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.okta.redirect-uri=http://localhost:8080/login/oauth2/code/okta
spring.security.oauth2.client.registration.okta.client-authentication-method=client_secret_basic

spring.security.oauth2.client.provider.okta.issuer-uri=https://{yourOktaDomain}/oauth2/default
spring.security.oauth2.client.provider.okta.authorization-uri=https://{yourOktaDomain}/oauth2/default/v1/authorize
spring.security.oauth2.client.provider.okta.token-uri=https://{yourOktaDomain}/oauth2/default/v1/token
spring.security.oauth2.client.provider.okta.user-info-uri=https://{yourOktaDomain}/oauth2/default/v1/userinfo
spring.security.oauth2.client.provider.okta.jwk-set-uri=https://{yourOktaDomain}/oauth2/default/v1/keys
This configuration sets up Okta as the OAuth 2.0 provider, and Spring Security will use these details to perform OAuth 2.0 authentication and authorization.

Create an Okta OIDC Application

You need to configure an Okta application in the Okta Developer Console:

Go to Applications > Add Application > Web.
Set up the redirect URI to http://localhost:8080/login/oauth2/code/okta.
Copy the Client ID and Client Secret to your application.properties.
Testing the Application

Once everything is configured, run your Spring application. When a user accesses a protected endpoint, they will be redirected to the Okta login page. After successful login, they’ll be redirected back to your application.

Example Flow:
The user accesses a protected resource.
They are redirected to Okta’s login page.
After logging in, they are redirected back to your app.
The OidcUser (Okta's OAuth 2.0 user) will be available in your controllers or security context.
Retrieving User Details:
In a Spring controller, you can access the authenticated user’s details (like email and name) via the Principal or OidcUser:

java
Copy code
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.core.oidc.user.OidcUser;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    @GetMapping("/user")
    public String getUserInfo(@AuthenticationPrincipal OidcUser oidcUser) {
        String email = oidcUser.getEmail();
        String fullName = oidcUser.getFullName();
        return "User: " + fullName + ", Email: " + email;
    }
}
This retrieves the user's full name and email address from Okta after authentication.

Summary
Although you're using an older version of Spring, you can integrate Okta using Spring Security's OAuth 2.0 support. The key points are:

Add necessary dependencies (okta-spring-security-oauth2 and Spring Security OAuth2 Client).
Manually configure Okta client details and OAuth2 flow in application.properties.
Use Spring Security’s oauth2Login() to handle the OAuth2 login flow.
Let me know if you have any more questions or need further clarification!

-----------------------------------------
